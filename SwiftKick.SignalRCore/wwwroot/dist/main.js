/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app.ts":
/*!****************!*\
  !*** ./app.ts ***!
  \****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar SignalR = __webpack_require__(/*! @aspnet/signalr */ \"./node_modules/@aspnet/signalr/dist/esm/index.js\");\r\nvar btn = document.getElementById(\"btnSend\");\r\nbtn.addEventListener(\"click\", function () { return sendMessage(); });\r\nfunction sendMessage() {\r\n    var messageToSend = document.getElementById(\"messageToSend\");\r\n    var val = messageToSend.value;\r\n    connection.invoke(\"broadcastMessage\", val);\r\n}\r\nvar connection = new SignalR.HubConnection(\"/chatHub\");\r\nconnection.on(\"writeMessage\", function (message) {\r\n    var el = document.getElementById(\"messages\");\r\n    var li = document.createElement(\"li\");\r\n    li.appendChild(document.createTextNode(message));\r\n    el.appendChild(li);\r\n});\r\nconnection.start().then(function () { console.log(\"Connected\"); });\r\n\n\n//# sourceURL=webpack:///./app.ts?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/AbortController.js":
/*!******************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/AbortController.js ***!
  \******************************************************************/
/*! exports provided: AbortController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbortController\", function() { return AbortController; });\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\r\n// it's a very new API right now.\r\nclass AbortController {\r\n    constructor() {\r\n        this.isAborted = false;\r\n    }\r\n    abort() {\r\n        if (!this.isAborted) {\r\n            this.isAborted = true;\r\n            if (this.onabort) {\r\n                this.onabort();\r\n            }\r\n        }\r\n    }\r\n    get signal() {\r\n        return this;\r\n    }\r\n    get aborted() {\r\n        return this.isAborted;\r\n    }\r\n}\r\n//# sourceMappingURL=AbortController.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/AbortController.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/Errors.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/Errors.js ***!
  \*********************************************************/
/*! exports provided: HttpError, TimeoutError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HttpError\", function() { return HttpError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeoutError\", function() { return TimeoutError; });\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nclass HttpError extends Error {\r\n    constructor(errorMessage, statusCode) {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n        this.statusCode = statusCode;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\nclass TimeoutError extends Error {\r\n    constructor(errorMessage = \"A timeout occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n//# sourceMappingURL=Errors.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/Errors.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/HttpClient.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/HttpClient.js ***!
  \*************************************************************/
/*! exports provided: HttpResponse, HttpClient, DefaultHttpClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HttpResponse\", function() { return HttpResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HttpClient\", function() { return HttpClient; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DefaultHttpClient\", function() { return DefaultHttpClient; });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ \"./node_modules/@aspnet/signalr/dist/esm/Errors.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@aspnet/signalr/dist/esm/ILogger.js\");\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\nclass HttpResponse {\r\n    constructor(statusCode, statusText, content) {\r\n        this.statusCode = statusCode;\r\n        this.statusText = statusText;\r\n        this.content = content;\r\n    }\r\n}\r\nclass HttpClient {\r\n    get(url, options) {\r\n        return this.send(Object.assign({}, options, { method: \"GET\", url }));\r\n    }\r\n    post(url, options) {\r\n        return this.send(Object.assign({}, options, { method: \"POST\", url }));\r\n    }\r\n}\r\nclass DefaultHttpClient extends HttpClient {\r\n    constructor(logger) {\r\n        super();\r\n        this.logger = logger;\r\n    }\r\n    send(request) {\r\n        return new Promise((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest();\r\n            xhr.open(request.method, request.url, true);\r\n            xhr.withCredentials = true;\r\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\r\n            if (request.headers) {\r\n                Object.keys(request.headers)\r\n                    .forEach((header) => xhr.setRequestHeader(header, request.headers[header]));\r\n            }\r\n            if (request.responseType) {\r\n                xhr.responseType = request.responseType;\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = () => {\r\n                    xhr.abort();\r\n                };\r\n            }\r\n            if (request.timeout) {\r\n                xhr.timeout = request.timeout;\r\n            }\r\n            xhr.onload = () => {\r\n                if (request.abortSignal) {\r\n                    request.abortSignal.onabort = null;\r\n                }\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\r\n                }\r\n                else {\r\n                    reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"HttpError\"](xhr.statusText, xhr.status));\r\n                }\r\n            };\r\n            xhr.onerror = () => {\r\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}`);\r\n                reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"HttpError\"](xhr.statusText, xhr.status));\r\n            };\r\n            xhr.ontimeout = () => {\r\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Warning, `Timeout from HTTP request.`);\r\n                reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__[\"TimeoutError\"]());\r\n            };\r\n            xhr.send(request.content || \"\");\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=HttpClient.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/HttpClient.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/HttpConnection.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/HttpConnection.js ***!
  \*****************************************************************/
/*! exports provided: HttpConnection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HttpConnection\", function() { return HttpConnection; });\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HttpClient */ \"./node_modules/@aspnet/signalr/dist/esm/HttpClient.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@aspnet/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Loggers */ \"./node_modules/@aspnet/signalr/dist/esm/Loggers.js\");\n/* harmony import */ var _Transports__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Transports */ \"./node_modules/@aspnet/signalr/dist/esm/Transports.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@aspnet/signalr/dist/esm/Utils.js\");\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass HttpConnection {\r\n    constructor(url, options = {}) {\r\n        this.features = {};\r\n        _Utils__WEBPACK_IMPORTED_MODULE_4__[\"Arg\"].isRequired(url, \"url\");\r\n        this.logger = _Loggers__WEBPACK_IMPORTED_MODULE_2__[\"LoggerFactory\"].createLogger(options.logger);\r\n        this.baseUrl = this.resolveUrl(url);\r\n        options = options || {};\r\n        options.accessTokenFactory = options.accessTokenFactory || (() => null);\r\n        this.httpClient = options.httpClient || new _HttpClient__WEBPACK_IMPORTED_MODULE_0__[\"DefaultHttpClient\"](this.logger);\r\n        this.connectionState = 2 /* Disconnected */;\r\n        this.options = options;\r\n    }\r\n    start(transferFormat) {\r\n        _Utils__WEBPACK_IMPORTED_MODULE_4__[\"Arg\"].isRequired(transferFormat, \"transferFormat\");\r\n        _Utils__WEBPACK_IMPORTED_MODULE_4__[\"Arg\"].isIn(transferFormat, _Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransferFormat\"], \"transferFormat\");\r\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Trace, `Starting connection with transfer format '${_Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransferFormat\"][transferFormat]}'.`);\r\n        if (this.connectionState !== 2 /* Disconnected */) {\r\n            return Promise.reject(new Error(\"Cannot start a connection that is not in the 'Disconnected' state.\"));\r\n        }\r\n        this.connectionState = 0 /* Connecting */;\r\n        this.startPromise = this.startInternal(transferFormat);\r\n        return this.startPromise;\r\n    }\r\n    startInternal(transferFormat) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                if (this.options.transport === _Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"].WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.url = this.baseUrl;\r\n                    this.transport = this.constructTransport(_Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"].WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    yield this.transport.connect(this.url, transferFormat, this);\r\n                }\r\n                else {\r\n                    const token = this.options.accessTokenFactory();\r\n                    let headers;\r\n                    if (token) {\r\n                        headers = {\r\n                            [\"Authorization\"]: `Bearer ${token}`,\r\n                        };\r\n                    }\r\n                    const negotiateResponse = yield this.getNegotiationResponse(headers);\r\n                    // the user tries to stop the the connection when it is being started\r\n                    if (this.connectionState === 2 /* Disconnected */) {\r\n                        return;\r\n                    }\r\n                    yield this.createTransport(this.options.transport, negotiateResponse, transferFormat, headers);\r\n                }\r\n                this.transport.onreceive = this.onreceive;\r\n                this.transport.onclose = (e) => this.stopConnection(true, e);\r\n                // only change the state if we were connecting to not overwrite\r\n                // the state if the connection is already marked as Disconnected\r\n                this.changeState(0 /* Connecting */, 1 /* Connected */);\r\n            }\r\n            catch (e) {\r\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, \"Failed to start the connection: \" + e);\r\n                this.connectionState = 2 /* Disconnected */;\r\n                this.transport = null;\r\n                throw e;\r\n            }\r\n        });\r\n    }\r\n    getNegotiationResponse(headers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const negotiateUrl = this.resolveNegotiateUrl(this.baseUrl);\r\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Trace, `Sending negotiation request: ${negotiateUrl}`);\r\n            try {\r\n                const response = yield this.httpClient.post(negotiateUrl, {\r\n                    content: \"\",\r\n                    headers,\r\n                });\r\n                return JSON.parse(response.content);\r\n            }\r\n            catch (e) {\r\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, \"Failed to complete negotiation with the server: \" + e);\r\n                throw e;\r\n            }\r\n        });\r\n    }\r\n    updateConnectionId(negotiateResponse) {\r\n        this.connectionId = negotiateResponse.connectionId;\r\n        this.url = this.baseUrl + (this.baseUrl.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${this.connectionId}`;\r\n    }\r\n    createTransport(requestedTransport, negotiateResponse, requestedTransferFormat, headers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.updateConnectionId(negotiateResponse);\r\n            if (this.isITransport(requestedTransport)) {\r\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Trace, \"Connection was provided an instance of ITransport, using that directly.\");\r\n                this.transport = requestedTransport;\r\n                yield this.transport.connect(this.url, requestedTransferFormat, this);\r\n                // only change the state if we were connecting to not overwrite\r\n                // the state if the connection is already marked as Disconnected\r\n                this.changeState(0 /* Connecting */, 1 /* Connected */);\r\n                return;\r\n            }\r\n            const transports = negotiateResponse.availableTransports;\r\n            for (const endpoint of transports) {\r\n                this.connectionState = 0 /* Connecting */;\r\n                const transport = this.resolveTransport(endpoint, requestedTransport, requestedTransferFormat);\r\n                if (typeof transport === \"number\") {\r\n                    this.transport = this.constructTransport(transport);\r\n                    if (negotiateResponse.connectionId === null) {\r\n                        negotiateResponse = yield this.getNegotiationResponse(headers);\r\n                        this.updateConnectionId(negotiateResponse);\r\n                    }\r\n                    try {\r\n                        yield this.transport.connect(this.url, requestedTransferFormat, this);\r\n                        this.changeState(0 /* Connecting */, 1 /* Connected */);\r\n                        return;\r\n                    }\r\n                    catch (ex) {\r\n                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, `Failed to start the transport '${_Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"][transport]}': ${ex}`);\r\n                        this.connectionState = 2 /* Disconnected */;\r\n                        negotiateResponse.connectionId = null;\r\n                    }\r\n                }\r\n            }\r\n            throw new Error(\"Unable to initialize any of the available transports.\");\r\n        });\r\n    }\r\n    constructTransport(transport) {\r\n        switch (transport) {\r\n            case _Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"].WebSockets:\r\n                return new _Transports__WEBPACK_IMPORTED_MODULE_3__[\"WebSocketTransport\"](this.options.accessTokenFactory, this.logger);\r\n            case _Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"].ServerSentEvents:\r\n                return new _Transports__WEBPACK_IMPORTED_MODULE_3__[\"ServerSentEventsTransport\"](this.httpClient, this.options.accessTokenFactory, this.logger);\r\n            case _Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"].LongPolling:\r\n                return new _Transports__WEBPACK_IMPORTED_MODULE_3__[\"LongPollingTransport\"](this.httpClient, this.options.accessTokenFactory, this.logger);\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n    resolveTransport(endpoint, requestedTransport, requestedTransferFormat) {\r\n        const transport = _Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"][endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Trace, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        }\r\n        else {\r\n            const transferFormats = endpoint.transferFormats.map((s) => _Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransferFormat\"][s]);\r\n            if (!requestedTransport || transport === requestedTransport) {\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === _Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"].WebSockets && typeof WebSocket === \"undefined\") ||\r\n                        (transport === _Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"].ServerSentEvents && typeof EventSource === \"undefined\")) {\r\n                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Trace, `Skipping transport '${_Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"][transport]}' because it is not supported in your environment.'`);\r\n                    }\r\n                    else {\r\n                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Trace, `Selecting transport '${_Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"][transport]}'`);\r\n                        return transport;\r\n                    }\r\n                }\r\n                else {\r\n                    this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Trace, `Skipping transport '${_Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"][transport]}' because it does not support the requested transfer format '${_Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransferFormat\"][requestedTransferFormat]}'.`);\r\n                }\r\n            }\r\n            else {\r\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Trace, `Skipping transport '${_Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransportType\"][transport]}' because it was disabled by the client.`);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    isITransport(transport) {\r\n        return typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n    changeState(from, to) {\r\n        if (this.connectionState === from) {\r\n            this.connectionState = to;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    send(data) {\r\n        if (this.connectionState !== 1 /* Connected */) {\r\n            throw new Error(\"Cannot send data if the connection is not in the 'Connected' State.\");\r\n        }\r\n        return this.transport.send(data);\r\n    }\r\n    stop(error) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const previousState = this.connectionState;\r\n            this.connectionState = 2 /* Disconnected */;\r\n            try {\r\n                yield this.startPromise;\r\n            }\r\n            catch (e) {\r\n                // this exception is returned to the user as a rejected Promise from the start method\r\n            }\r\n            this.stopConnection(/*raiseClosed*/ previousState === 1 /* Connected */, error);\r\n        });\r\n    }\r\n    stopConnection(raiseClosed, error) {\r\n        if (this.transport) {\r\n            this.transport.stop();\r\n            this.transport = null;\r\n        }\r\n        if (error) {\r\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, `Connection disconnected with error '${error}'.`);\r\n        }\r\n        else {\r\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Information, \"Connection disconnected.\");\r\n        }\r\n        this.connectionState = 2 /* Disconnected */;\r\n        if (raiseClosed && this.onclose) {\r\n            this.onclose(error);\r\n        }\r\n    }\r\n    resolveUrl(url) {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n        if (typeof window === \"undefined\" || !window || !window.document) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n        const parser = window.document.createElement(\"a\");\r\n        parser.href = url;\r\n        const baseUrl = (!parser.protocol || parser.protocol === \":\")\r\n            ? `${window.document.location.protocol}//${(parser.host || window.document.location.host)}`\r\n            : `${parser.protocol}//${parser.host}`;\r\n        if (!url || url[0] !== \"/\") {\r\n            url = \"/\" + url;\r\n        }\r\n        const normalizedUrl = baseUrl + url;\r\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Information, `Normalizing '${url}' to '${normalizedUrl}'.`);\r\n        return normalizedUrl;\r\n    }\r\n    resolveNegotiateUrl(url) {\r\n        const index = url.indexOf(\"?\");\r\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\r\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\r\n            negotiateUrl += \"/\";\r\n        }\r\n        negotiateUrl += \"negotiate\";\r\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\r\n        return negotiateUrl;\r\n    }\r\n}\r\n//# sourceMappingURL=HttpConnection.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/HttpConnection.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/HubConnection.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/HubConnection.js ***!
  \****************************************************************/
/*! exports provided: JsonHubProtocol, HubConnection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HubConnection\", function() { return HubConnection; });\n/* harmony import */ var _HttpConnection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HttpConnection */ \"./node_modules/@aspnet/signalr/dist/esm/HttpConnection.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@aspnet/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JsonHubProtocol */ \"./node_modules/@aspnet/signalr/dist/esm/JsonHubProtocol.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"JsonHubProtocol\", function() { return _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_2__[\"JsonHubProtocol\"]; });\n\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Loggers */ \"./node_modules/@aspnet/signalr/dist/esm/Loggers.js\");\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Observable */ \"./node_modules/@aspnet/signalr/dist/esm/Observable.js\");\n/* harmony import */ var _TextMessageFormat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TextMessageFormat */ \"./node_modules/@aspnet/signalr/dist/esm/TextMessageFormat.js\");\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\r\nclass HubConnection {\r\n    constructor(urlOrConnection, options = {}) {\r\n        options = options || {};\r\n        this.timeoutInMilliseconds = options.timeoutInMilliseconds || DEFAULT_TIMEOUT_IN_MS;\r\n        this.protocol = options.protocol || new _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_2__[\"JsonHubProtocol\"]();\r\n        if (typeof urlOrConnection === \"string\") {\r\n            this.connection = new _HttpConnection__WEBPACK_IMPORTED_MODULE_0__[\"HttpConnection\"](urlOrConnection, options);\r\n        }\r\n        else {\r\n            this.connection = urlOrConnection;\r\n        }\r\n        this.logger = _Loggers__WEBPACK_IMPORTED_MODULE_3__[\"LoggerFactory\"].createLogger(options.logger);\r\n        this.connection.onreceive = (data) => this.processIncomingData(data);\r\n        this.connection.onclose = (error) => this.connectionClosed(error);\r\n        this.callbacks = {};\r\n        this.methods = {};\r\n        this.closedCallbacks = [];\r\n        this.id = 0;\r\n    }\r\n    processIncomingData(data) {\r\n        this.cleanupTimeout();\r\n        if (!this.receivedHandshakeResponse) {\r\n            data = this.processHandshakeResponse(data);\r\n            this.receivedHandshakeResponse = true;\r\n        }\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this.protocol.parseMessages(data, this.logger);\r\n            for (const message of messages) {\r\n                switch (message.type) {\r\n                    case 1 /* Invocation */:\r\n                        this.invokeClientMethod(message);\r\n                        break;\r\n                    case 2 /* StreamItem */:\r\n                    case 3 /* Completion */:\r\n                        const callback = this.callbacks[message.invocationId];\r\n                        if (callback != null) {\r\n                            if (message.type === 3 /* Completion */) {\r\n                                delete this.callbacks[message.invocationId];\r\n                            }\r\n                            callback(message);\r\n                        }\r\n                        break;\r\n                    case 6 /* Ping */:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case 7 /* Close */:\r\n                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Information, \"Close message received from server.\");\r\n                        this.connection.stop(message.error ? new Error(\"Server returned an error on close: \" + message.error) : null);\r\n                        break;\r\n                    default:\r\n                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Warning, \"Invalid message type: \" + message.type);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        this.configureTimeout();\r\n    }\r\n    processHandshakeResponse(data) {\r\n        let responseMessage;\r\n        let messageData;\r\n        let remainingData;\r\n        try {\r\n            if (data instanceof ArrayBuffer) {\r\n                // Format is binary but still need to read JSON text from handshake response\r\n                const binaryData = new Uint8Array(data);\r\n                const separatorIndex = binaryData.indexOf(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_5__[\"TextMessageFormat\"].RecordSeparatorCode);\r\n                if (separatorIndex === -1) {\r\n                    throw new Error(\"Message is incomplete.\");\r\n                }\r\n                // content before separator is handshake response\r\n                // optional content after is additional messages\r\n                const responseLength = separatorIndex + 1;\r\n                messageData = String.fromCharCode.apply(null, binaryData.slice(0, responseLength));\r\n                remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\r\n            }\r\n            else {\r\n                const textData = data;\r\n                const separatorIndex = textData.indexOf(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_5__[\"TextMessageFormat\"].RecordSeparator);\r\n                if (separatorIndex === -1) {\r\n                    throw new Error(\"Message is incomplete.\");\r\n                }\r\n                // content before separator is handshake response\r\n                // optional content after is additional messages\r\n                const responseLength = separatorIndex + 1;\r\n                messageData = textData.substring(0, responseLength);\r\n                remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\r\n            }\r\n            // At this point we should have just the single handshake message\r\n            const messages = _TextMessageFormat__WEBPACK_IMPORTED_MODULE_5__[\"TextMessageFormat\"].parse(messageData);\r\n            responseMessage = JSON.parse(messages[0]);\r\n        }\r\n        catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, message);\r\n            const error = new Error(message);\r\n            this.connection.stop(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, message);\r\n            this.connection.stop(new Error(message));\r\n        }\r\n        else {\r\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Trace, \"Server handshake complete.\");\r\n        }\r\n        // multiple messages could have arrived with handshake\r\n        // return additional data to be parsed as usual, or null if all parsed\r\n        return remainingData;\r\n    }\r\n    configureTimeout() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this.timeoutHandle = setTimeout(() => this.serverTimeout(), this.timeoutInMilliseconds);\r\n        }\r\n    }\r\n    serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n    invokeClientMethod(invocationMessage) {\r\n        const methods = this.methods[invocationMessage.target.toLowerCase()];\r\n        if (methods) {\r\n            methods.forEach((m) => m.apply(this, invocationMessage.arguments));\r\n            if (invocationMessage.invocationId) {\r\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\r\n                const message = \"Server requested a response, which is not supported in this version of the client.\";\r\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Error, message);\r\n                this.connection.stop(new Error(message));\r\n            }\r\n        }\r\n        else {\r\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Warning, `No client method with the name '${invocationMessage.target}' found.`);\r\n        }\r\n    }\r\n    connectionClosed(error) {\r\n        const callbacks = this.callbacks;\r\n        this.callbacks = {};\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n            const callback = callbacks[key];\r\n            callback(undefined, error ? error : new Error(\"Invocation canceled due to connection being closed.\"));\r\n        });\r\n        this.cleanupTimeout();\r\n        this.closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n    }\r\n    start() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Trace, \"Starting HubConnection.\");\r\n            this.receivedHandshakeResponse = false;\r\n            yield this.connection.start(this.protocol.transferFormat);\r\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Trace, \"Sending handshake request.\");\r\n            // Handshake request is always JSON\r\n            yield this.connection.send(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_5__[\"TextMessageFormat\"].write(JSON.stringify({ protocol: this.protocol.name, version: this.protocol.version })));\r\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Information, `Using HubProtocol '${this.protocol.name}'.`);\r\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n            this.cleanupTimeout();\r\n            this.configureTimeout();\r\n        });\r\n    }\r\n    stop() {\r\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__[\"LogLevel\"].Trace, \"Stopping HubConnection.\");\r\n        this.cleanupTimeout();\r\n        return this.connection.stop();\r\n    }\r\n    stream(methodName, ...args) {\r\n        const invocationDescriptor = this.createStreamInvocation(methodName, args);\r\n        const subject = new _Observable__WEBPACK_IMPORTED_MODULE_4__[\"Subject\"](() => {\r\n            const cancelInvocation = this.createCancelInvocation(invocationDescriptor.invocationId);\r\n            const cancelMessage = this.protocol.writeMessage(cancelInvocation);\r\n            delete this.callbacks[invocationDescriptor.invocationId];\r\n            return this.connection.send(cancelMessage);\r\n        });\r\n        this.callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            }\r\n            if (invocationEvent.type === 3 /* Completion */) {\r\n                if (invocationEvent.error) {\r\n                    subject.error(new Error(invocationEvent.error));\r\n                }\r\n                else {\r\n                    subject.complete();\r\n                }\r\n            }\r\n            else {\r\n                subject.next((invocationEvent.item));\r\n            }\r\n        };\r\n        const message = this.protocol.writeMessage(invocationDescriptor);\r\n        this.connection.send(message)\r\n            .catch((e) => {\r\n            subject.error(e);\r\n            delete this.callbacks[invocationDescriptor.invocationId];\r\n        });\r\n        return subject;\r\n    }\r\n    send(methodName, ...args) {\r\n        const invocationDescriptor = this.createInvocation(methodName, args, true);\r\n        const message = this.protocol.writeMessage(invocationDescriptor);\r\n        return this.connection.send(message);\r\n    }\r\n    invoke(methodName, ...args) {\r\n        const invocationDescriptor = this.createInvocation(methodName, args, false);\r\n        const p = new Promise((resolve, reject) => {\r\n            this.callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                if (invocationEvent.type === 3 /* Completion */) {\r\n                    const completionMessage = invocationEvent;\r\n                    if (completionMessage.error) {\r\n                        reject(new Error(completionMessage.error));\r\n                    }\r\n                    else {\r\n                        resolve(completionMessage.result);\r\n                    }\r\n                }\r\n                else {\r\n                    reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                }\r\n            };\r\n            const message = this.protocol.writeMessage(invocationDescriptor);\r\n            this.connection.send(message)\r\n                .catch((e) => {\r\n                reject(e);\r\n                delete this.callbacks[invocationDescriptor.invocationId];\r\n            });\r\n        });\r\n        return p;\r\n    }\r\n    on(methodName, newMethod) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        if (!this.methods[methodName]) {\r\n            this.methods[methodName] = [];\r\n        }\r\n        // Preventing adding the same handler multiple times.\r\n        if (this.methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n        this.methods[methodName].push(newMethod);\r\n    }\r\n    off(methodName, method) {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this.methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this.methods[methodName];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            delete this.methods[methodName];\r\n        }\r\n    }\r\n    onclose(callback) {\r\n        if (callback) {\r\n            this.closedCallbacks.push(callback);\r\n        }\r\n    }\r\n    cleanupTimeout() {\r\n        if (this.timeoutHandle) {\r\n            clearTimeout(this.timeoutHandle);\r\n        }\r\n    }\r\n    createInvocation(methodName, args, nonblocking) {\r\n        if (nonblocking) {\r\n            return {\r\n                arguments: args,\r\n                target: methodName,\r\n                type: 1 /* Invocation */,\r\n            };\r\n        }\r\n        else {\r\n            const id = this.id;\r\n            this.id++;\r\n            return {\r\n                arguments: args,\r\n                invocationId: id.toString(),\r\n                target: methodName,\r\n                type: 1 /* Invocation */,\r\n            };\r\n        }\r\n    }\r\n    createStreamInvocation(methodName, args) {\r\n        const id = this.id;\r\n        this.id++;\r\n        return {\r\n            arguments: args,\r\n            invocationId: id.toString(),\r\n            target: methodName,\r\n            type: 4 /* StreamInvocation */,\r\n        };\r\n    }\r\n    createCancelInvocation(id) {\r\n        return {\r\n            invocationId: id,\r\n            type: 5 /* CancelInvocation */,\r\n        };\r\n    }\r\n}\r\n//# sourceMappingURL=HubConnection.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/HubConnection.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/IHubProtocol.js":
/*!***************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/IHubProtocol.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//# sourceMappingURL=IHubProtocol.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/IHubProtocol.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/ILogger.js":
/*!**********************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/ILogger.js ***!
  \**********************************************************/
/*! exports provided: LogLevel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LogLevel\", function() { return LogLevel; });\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\r\n    LogLevel[LogLevel[\"Information\"] = 1] = \"Information\";\r\n    LogLevel[LogLevel[\"Warning\"] = 2] = \"Warning\";\r\n    LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\r\n    LogLevel[LogLevel[\"None\"] = 4] = \"None\";\r\n})(LogLevel || (LogLevel = {}));\r\n//# sourceMappingURL=ILogger.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/ILogger.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/JsonHubProtocol.js":
/*!******************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/JsonHubProtocol.js ***!
  \******************************************************************/
/*! exports provided: JSON_HUB_PROTOCOL_NAME, JsonHubProtocol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JSON_HUB_PROTOCOL_NAME\", function() { return JSON_HUB_PROTOCOL_NAME; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JsonHubProtocol\", function() { return JsonHubProtocol; });\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@aspnet/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loggers */ \"./node_modules/@aspnet/signalr/dist/esm/Loggers.js\");\n/* harmony import */ var _TextMessageFormat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TextMessageFormat */ \"./node_modules/@aspnet/signalr/dist/esm/TextMessageFormat.js\");\n/* harmony import */ var _Transports__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Transports */ \"./node_modules/@aspnet/signalr/dist/esm/Transports.js\");\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n\r\n\r\nconst JSON_HUB_PROTOCOL_NAME = \"json\";\r\nclass JsonHubProtocol {\r\n    constructor() {\r\n        this.name = JSON_HUB_PROTOCOL_NAME;\r\n        this.version = 1;\r\n        this.transferFormat = _Transports__WEBPACK_IMPORTED_MODULE_3__[\"TransferFormat\"].Text;\r\n    }\r\n    parseMessages(input, logger) {\r\n        if (!input) {\r\n            return [];\r\n        }\r\n        if (logger === null) {\r\n            logger = new _Loggers__WEBPACK_IMPORTED_MODULE_1__[\"NullLogger\"]();\r\n        }\r\n        // Parse the messages\r\n        const messages = _TextMessageFormat__WEBPACK_IMPORTED_MODULE_2__[\"TextMessageFormat\"].parse(input);\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = JSON.parse(message);\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case 1 /* Invocation */:\r\n                    this.isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case 2 /* StreamItem */:\r\n                    this.isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case 3 /* Completion */:\r\n                    this.isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case 6 /* Ping */:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case 7 /* Close */:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n        return hubMessages;\r\n    }\r\n    writeMessage(message) {\r\n        return _TextMessageFormat__WEBPACK_IMPORTED_MODULE_2__[\"TextMessageFormat\"].write(JSON.stringify(message));\r\n    }\r\n    isInvocationMessage(message) {\r\n        this.assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n        if (message.invocationId !== undefined) {\r\n            this.assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    }\r\n    isStreamItemMessage(message) {\r\n        this.assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    }\r\n    isCompletionMessage(message) {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n        if (!message.result && message.error) {\r\n            this.assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n        this.assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    }\r\n    assertNotEmptyString(value, errorMessage) {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=JsonHubProtocol.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/JsonHubProtocol.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/Loggers.js":
/*!**********************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/Loggers.js ***!
  \**********************************************************/
/*! exports provided: NullLogger, ConsoleLogger, LoggerFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NullLogger\", function() { return NullLogger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConsoleLogger\", function() { return ConsoleLogger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoggerFactory\", function() { return LoggerFactory; });\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@aspnet/signalr/dist/esm/ILogger.js\");\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nclass NullLogger {\r\n    log(logLevel, message) {\r\n    }\r\n}\r\nclass ConsoleLogger {\r\n    constructor(minimumLogLevel) {\r\n        this.minimumLogLevel = minimumLogLevel;\r\n    }\r\n    log(logLevel, message) {\r\n        if (logLevel >= this.minimumLogLevel) {\r\n            switch (logLevel) {\r\n                case _ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Error:\r\n                    console.error(`${_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"][logLevel]}: ${message}`);\r\n                    break;\r\n                case _ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Warning:\r\n                    console.warn(`${_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"][logLevel]}: ${message}`);\r\n                    break;\r\n                case _ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Information:\r\n                    console.info(`${_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"][logLevel]}: ${message}`);\r\n                    break;\r\n                default:\r\n                    console.log(`${_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"][logLevel]}: ${message}`);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\nclass LoggerFactory {\r\n    static createLogger(logging) {\r\n        if (logging === undefined) {\r\n            return new ConsoleLogger(_ILogger__WEBPACK_IMPORTED_MODULE_0__[\"LogLevel\"].Information);\r\n        }\r\n        if (logging === null) {\r\n            return new NullLogger();\r\n        }\r\n        if (logging.log) {\r\n            return logging;\r\n        }\r\n        return new ConsoleLogger(logging);\r\n    }\r\n}\r\n//# sourceMappingURL=Loggers.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/Loggers.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/Observable.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/Observable.js ***!
  \*************************************************************/
/*! exports provided: Subscription, Subject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Subscription\", function() { return Subscription; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Subject\", function() { return Subject; });\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nclass Subscription {\r\n    constructor(subject, observer) {\r\n        this.subject = subject;\r\n        this.observer = observer;\r\n    }\r\n    dispose() {\r\n        const index = this.subject.observers.indexOf(this.observer);\r\n        if (index > -1) {\r\n            this.subject.observers.splice(index, 1);\r\n        }\r\n        if (this.subject.observers.length === 0) {\r\n            this.subject.cancelCallback().catch((_) => { });\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor(cancelCallback) {\r\n        this.observers = [];\r\n        this.cancelCallback = cancelCallback;\r\n    }\r\n    next(item) {\r\n        for (const observer of this.observers) {\r\n            observer.next(item);\r\n        }\r\n    }\r\n    error(err) {\r\n        for (const observer of this.observers) {\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    }\r\n    complete() {\r\n        for (const observer of this.observers) {\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        this.observers.push(observer);\r\n        return new Subscription(this, observer);\r\n    }\r\n}\r\n//# sourceMappingURL=Observable.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/Observable.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/TextMessageFormat.js":
/*!********************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/TextMessageFormat.js ***!
  \********************************************************************/
/*! exports provided: TextMessageFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextMessageFormat\", function() { return TextMessageFormat; });\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nclass TextMessageFormat {\r\n    static write(output) {\r\n        return `${output}${TextMessageFormat.RecordSeparator}`;\r\n    }\r\n    static parse(input) {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n        const messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    }\r\n}\r\nTextMessageFormat.RecordSeparatorCode = 0x1e;\r\nTextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n//# sourceMappingURL=TextMessageFormat.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/TextMessageFormat.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/Transports.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/Transports.js ***!
  \*************************************************************/
/*! exports provided: TransportType, TransferFormat, WebSocketTransport, ServerSentEventsTransport, LongPollingTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransportType\", function() { return TransportType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransferFormat\", function() { return TransferFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebSocketTransport\", function() { return WebSocketTransport; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ServerSentEventsTransport\", function() { return ServerSentEventsTransport; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LongPollingTransport\", function() { return LongPollingTransport; });\n/* harmony import */ var _AbortController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbortController */ \"./node_modules/@aspnet/signalr/dist/esm/AbortController.js\");\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Errors */ \"./node_modules/@aspnet/signalr/dist/esm/Errors.js\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@aspnet/signalr/dist/esm/ILogger.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ \"./node_modules/@aspnet/signalr/dist/esm/Utils.js\");\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nvar TransportType;\r\n(function (TransportType) {\r\n    TransportType[TransportType[\"WebSockets\"] = 0] = \"WebSockets\";\r\n    TransportType[TransportType[\"ServerSentEvents\"] = 1] = \"ServerSentEvents\";\r\n    TransportType[TransportType[\"LongPolling\"] = 2] = \"LongPolling\";\r\n})(TransportType || (TransportType = {}));\r\nvar TransferFormat;\r\n(function (TransferFormat) {\r\n    TransferFormat[TransferFormat[\"Text\"] = 1] = \"Text\";\r\n    TransferFormat[TransferFormat[\"Binary\"] = 2] = \"Binary\";\r\n})(TransferFormat || (TransferFormat = {}));\r\nclass WebSocketTransport {\r\n    constructor(accessTokenFactory, logger) {\r\n        this.logger = logger;\r\n        this.accessTokenFactory = accessTokenFactory || (() => null);\r\n    }\r\n    connect(url, transferFormat, connection) {\r\n        _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Arg\"].isRequired(url, \"url\");\r\n        _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Arg\"].isRequired(transferFormat, \"transferFormat\");\r\n        _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Arg\"].isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Arg\"].isRequired(connection, \"connection\");\r\n        if (typeof (WebSocket) === \"undefined\") {\r\n            throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n        }\r\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(WebSockets transport) Connecting\");\r\n        return new Promise((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            const token = this.accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n            const webSocket = new WebSocket(url);\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n            webSocket.onopen = (event) => {\r\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Information, `WebSocket connected to ${url}`);\r\n                this.webSocket = webSocket;\r\n                resolve();\r\n            };\r\n            webSocket.onerror = (event) => {\r\n                reject(event.error);\r\n            };\r\n            webSocket.onmessage = (message) => {\r\n                this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, `(WebSockets transport) data received. ${getDataDetail(message.data)}.`);\r\n                if (this.onreceive) {\r\n                    this.onreceive(message.data);\r\n                }\r\n            };\r\n            webSocket.onclose = (event) => {\r\n                // webSocket will be null if the transport did not start successfully\r\n                if (this.onclose && this.webSocket) {\r\n                    if (event.wasClean === false || event.code !== 1000) {\r\n                        this.onclose(new Error(`Websocket closed with status code: ${event.code} (${event.reason})`));\r\n                    }\r\n                    else {\r\n                        this.onclose();\r\n                    }\r\n                }\r\n            };\r\n        });\r\n    }\r\n    send(data) {\r\n        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\r\n            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, `(WebSockets transport) sending data. ${getDataDetail(data)}.`);\r\n            this.webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n    stop() {\r\n        if (this.webSocket) {\r\n            this.webSocket.close();\r\n            this.webSocket = null;\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n}\r\nclass ServerSentEventsTransport {\r\n    constructor(httpClient, accessTokenFactory, logger) {\r\n        this.httpClient = httpClient;\r\n        this.accessTokenFactory = accessTokenFactory || (() => null);\r\n        this.logger = logger;\r\n    }\r\n    connect(url, transferFormat, connection) {\r\n        _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Arg\"].isRequired(url, \"url\");\r\n        _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Arg\"].isRequired(transferFormat, \"transferFormat\");\r\n        _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Arg\"].isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Arg\"].isRequired(connection, \"connection\");\r\n        if (typeof (EventSource) === \"undefined\") {\r\n            throw new Error(\"'EventSource' is not supported in your environment.\");\r\n        }\r\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(SSE transport) Connecting\");\r\n        this.url = url;\r\n        return new Promise((resolve, reject) => {\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n            }\r\n            const token = this.accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n            const eventSource = new EventSource(url, { withCredentials: true });\r\n            try {\r\n                eventSource.onmessage = (e) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, `(SSE transport) data received. ${getDataDetail(e.data)}.`);\r\n                            this.onreceive(e.data);\r\n                        }\r\n                        catch (error) {\r\n                            if (this.onclose) {\r\n                                this.onclose(error);\r\n                            }\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n                eventSource.onerror = (e) => {\r\n                    reject(new Error(e.message || \"Error occurred\"));\r\n                    // don't report an error if the transport did not start successfully\r\n                    if (this.eventSource && this.onclose) {\r\n                        this.onclose(new Error(e.message || \"Error occurred\"));\r\n                    }\r\n                };\r\n                eventSource.onopen = () => {\r\n                    this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Information, `SSE connected to ${this.url}`);\r\n                    this.eventSource = eventSource;\r\n                    // SSE is a text protocol\r\n                    resolve();\r\n                };\r\n            }\r\n            catch (e) {\r\n                return Promise.reject(e);\r\n            }\r\n        });\r\n    }\r\n    send(data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return send(this.logger, \"SSE\", this.httpClient, this.url, this.accessTokenFactory, data);\r\n        });\r\n    }\r\n    stop() {\r\n        if (this.eventSource) {\r\n            this.eventSource.close();\r\n            this.eventSource = null;\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n}\r\nclass LongPollingTransport {\r\n    constructor(httpClient, accessTokenFactory, logger) {\r\n        this.httpClient = httpClient;\r\n        this.accessTokenFactory = accessTokenFactory || (() => null);\r\n        this.logger = logger;\r\n        this.pollAbort = new _AbortController__WEBPACK_IMPORTED_MODULE_0__[\"AbortController\"]();\r\n    }\r\n    connect(url, transferFormat, connection) {\r\n        _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Arg\"].isRequired(url, \"url\");\r\n        _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Arg\"].isRequired(transferFormat, \"transferFormat\");\r\n        _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Arg\"].isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        _Utils__WEBPACK_IMPORTED_MODULE_3__[\"Arg\"].isRequired(connection, \"connection\");\r\n        this.url = url;\r\n        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) Connecting\");\r\n        // Set a flag indicating we have inherent keep-alive in this transport.\r\n        connection.features.inherentKeepAlive = true;\r\n        if (transferFormat === TransferFormat.Binary && (typeof new XMLHttpRequest().responseType !== \"string\")) {\r\n            // This will work if we fix: https://github.com/aspnet/SignalR/issues/742\r\n            throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\r\n        }\r\n        this.poll(this.url, transferFormat);\r\n        return Promise.resolve();\r\n    }\r\n    poll(url, transferFormat) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const pollOptions = {\r\n                abortSignal: this.pollAbort.signal,\r\n                headers: {},\r\n                timeout: 90000,\r\n            };\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                pollOptions.responseType = \"arraybuffer\";\r\n            }\r\n            const token = this.accessTokenFactory();\r\n            if (token) {\r\n                // tslint:disable-next-line:no-string-literal\r\n                pollOptions.headers[\"Authorization\"] = `Bearer ${token}`;\r\n            }\r\n            while (!this.pollAbort.signal.aborted) {\r\n                try {\r\n                    const pollUrl = `${url}&_=${Date.now()}`;\r\n                    this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, `(LongPolling transport) polling: ${pollUrl}`);\r\n                    const response = yield this.httpClient.get(pollUrl, pollOptions);\r\n                    if (response.statusCode === 204) {\r\n                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Information, \"(LongPolling transport) Poll terminated by server\");\r\n                        // Poll terminated by server\r\n                        if (this.onclose) {\r\n                            this.onclose();\r\n                        }\r\n                        this.pollAbort.abort();\r\n                    }\r\n                    else if (response.statusCode !== 200) {\r\n                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}`);\r\n                        // Unexpected status code\r\n                        if (this.onclose) {\r\n                            this.onclose(new _Errors__WEBPACK_IMPORTED_MODULE_1__[\"HttpError\"](response.statusText, response.statusCode));\r\n                        }\r\n                        this.pollAbort.abort();\r\n                    }\r\n                    else {\r\n                        // Process the response\r\n                        if (response.content) {\r\n                            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, `(LongPolling transport) data received. ${getDataDetail(response.content)}.`);\r\n                            if (this.onreceive) {\r\n                                this.onreceive(response.content);\r\n                            }\r\n                        }\r\n                        else {\r\n                            // This is another way timeout manifest.\r\n                            this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    if (e instanceof _Errors__WEBPACK_IMPORTED_MODULE_1__[\"TimeoutError\"]) {\r\n                        // Ignore timeouts and reissue the poll.\r\n                        this.logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                    }\r\n                    else {\r\n                        // Close the connection with the error as the result.\r\n                        if (this.onclose) {\r\n                            this.onclose(e);\r\n                        }\r\n                        this.pollAbort.abort();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    send(data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return send(this.logger, \"LongPolling\", this.httpClient, this.url, this.accessTokenFactory, data);\r\n        });\r\n    }\r\n    stop() {\r\n        this.pollAbort.abort();\r\n        return Promise.resolve();\r\n    }\r\n}\r\nfunction getDataDetail(data) {\r\n    let length = null;\r\n    if (data instanceof ArrayBuffer) {\r\n        length = `Binary data of length ${data.byteLength}`;\r\n    }\r\n    else if (typeof data === \"string\") {\r\n        length = `String data of length ${data.length}`;\r\n    }\r\n    return length;\r\n}\r\nfunction send(logger, transportName, httpClient, url, accessTokenFactory, content) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let headers;\r\n        const token = accessTokenFactory();\r\n        if (token) {\r\n            headers = {\r\n                [\"Authorization\"]: `Bearer ${accessTokenFactory()}`,\r\n            };\r\n        }\r\n        logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, `(${transportName} transport) sending data. ${getDataDetail(content)}.`);\r\n        const response = yield httpClient.post(url, {\r\n            content,\r\n            headers,\r\n        });\r\n        logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__[\"LogLevel\"].Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\r\n    });\r\n}\r\n//# sourceMappingURL=Transports.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/Transports.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/Utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/Utils.js ***!
  \********************************************************/
/*! exports provided: Arg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Arg\", function() { return Arg; });\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nclass Arg {\r\n    static isRequired(val, name) {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(`The '${name}' argument is required.`);\r\n        }\r\n    }\r\n    static isIn(val, values, name) {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(`Unknown ${name} value: ${val}.`);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=Utils.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/Utils.js?");

/***/ }),

/***/ "./node_modules/@aspnet/signalr/dist/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@aspnet/signalr/dist/esm/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ \"./node_modules/@aspnet/signalr/dist/esm/Errors.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HttpError\", function() { return _Errors__WEBPACK_IMPORTED_MODULE_0__[\"HttpError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TimeoutError\", function() { return _Errors__WEBPACK_IMPORTED_MODULE_0__[\"TimeoutError\"]; });\n\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ \"./node_modules/@aspnet/signalr/dist/esm/HttpClient.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HttpResponse\", function() { return _HttpClient__WEBPACK_IMPORTED_MODULE_1__[\"HttpResponse\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HttpClient\", function() { return _HttpClient__WEBPACK_IMPORTED_MODULE_1__[\"HttpClient\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DefaultHttpClient\", function() { return _HttpClient__WEBPACK_IMPORTED_MODULE_1__[\"DefaultHttpClient\"]; });\n\n/* harmony import */ var _HttpConnection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HttpConnection */ \"./node_modules/@aspnet/signalr/dist/esm/HttpConnection.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HttpConnection\", function() { return _HttpConnection__WEBPACK_IMPORTED_MODULE_2__[\"HttpConnection\"]; });\n\n/* harmony import */ var _HubConnection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HubConnection */ \"./node_modules/@aspnet/signalr/dist/esm/HubConnection.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"JsonHubProtocol\", function() { return _HubConnection__WEBPACK_IMPORTED_MODULE_3__[\"JsonHubProtocol\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HubConnection\", function() { return _HubConnection__WEBPACK_IMPORTED_MODULE_3__[\"HubConnection\"]; });\n\n/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./IHubProtocol */ \"./node_modules/@aspnet/signalr/dist/esm/IHubProtocol.js\");\n/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_IHubProtocol__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _IHubProtocol__WEBPACK_IMPORTED_MODULE_4__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _IHubProtocol__WEBPACK_IMPORTED_MODULE_4__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ILogger */ \"./node_modules/@aspnet/signalr/dist/esm/ILogger.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LogLevel\", function() { return _ILogger__WEBPACK_IMPORTED_MODULE_5__[\"LogLevel\"]; });\n\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Loggers */ \"./node_modules/@aspnet/signalr/dist/esm/Loggers.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NullLogger\", function() { return _Loggers__WEBPACK_IMPORTED_MODULE_6__[\"NullLogger\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ConsoleLogger\", function() { return _Loggers__WEBPACK_IMPORTED_MODULE_6__[\"ConsoleLogger\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LoggerFactory\", function() { return _Loggers__WEBPACK_IMPORTED_MODULE_6__[\"LoggerFactory\"]; });\n\n/* harmony import */ var _Transports__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Transports */ \"./node_modules/@aspnet/signalr/dist/esm/Transports.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransportType\", function() { return _Transports__WEBPACK_IMPORTED_MODULE_7__[\"TransportType\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransferFormat\", function() { return _Transports__WEBPACK_IMPORTED_MODULE_7__[\"TransferFormat\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WebSocketTransport\", function() { return _Transports__WEBPACK_IMPORTED_MODULE_7__[\"WebSocketTransport\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ServerSentEventsTransport\", function() { return _Transports__WEBPACK_IMPORTED_MODULE_7__[\"ServerSentEventsTransport\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LongPollingTransport\", function() { return _Transports__WEBPACK_IMPORTED_MODULE_7__[\"LongPollingTransport\"]; });\n\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Observable */ \"./node_modules/@aspnet/signalr/dist/esm/Observable.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Subscription\", function() { return _Observable__WEBPACK_IMPORTED_MODULE_8__[\"Subscription\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Subject\", function() { return _Observable__WEBPACK_IMPORTED_MODULE_8__[\"Subject\"]; });\n\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@aspnet/signalr/dist/esm/index.js?");

/***/ })

/******/ });